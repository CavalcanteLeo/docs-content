---
title: Your first form
description: Creating your first form and understanding FormKit.
---

# Your first form

<page-toc></page-toc>

## Introduction

Let's start by creating our first FormKit form! We'll learn some of FormKit's key features and how they benefit you. We'll also pick up some nice tips along the way — like how to manage form state without using `v-model`.

<callout type="info" label="Composition API">
This guide assumes you are are familiar with the <a href="https://vuejs.org/guide/introduction.html#api-styles">Vue Composition API</a>.
</callout>

## Our first input

One of the main features of FormKit is its single component API — the `<FormKit />` component. This one component gives you access to *all* input types. And while some types may extend and add features, they share the same base functionality. You can learn more about inputs [here](/essentials/inputs).

Even without any props, the bare `<FormKit />` component has already given our input a great starting point, with accessible markup, a base `text` input type, and additional features that will be explained in later sections.

### Basic props

#### The type

By default, the `<FormKit />` component will use `type="text"` if no `type` is specified. The `type` is how we specify what input we want. Just like [native inputs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input), we have inputs like `text`, `select`, `checkbox` and so on. However, we are not confined to only "native" inputs, FormKit Pro adds non-native controls like the `repeater`, `taglist`, and `autocomplete` types, which can handle more complex interactions.

<example
  name="First input"
  file="_content/examples/guides/your-first-form/first-input/example.vue">
</example>

#### The name and id

If you look at the HTML generated by the previous example, you will see that FormKit already created accessible markup. However, as we did not specify the `name` and `id` properties, they were auto-generated for us: `name="text_1" id="input_0"`. Even so, we should always specify the `name` and `id`, as it makes using inputs inside a form easier. These props are used by the `form` and `group` types to collect values from, and pass values down to, their children based on the `name`:

<example
  name="Adding name and id"
  file="_content/examples/guides/your-first-form/input-name-id/example.vue">
</example>

#### Props for accessibility

Our input is still missing some key accessibility functionality like a `label`, `help`, and maybe even a `placeholder`. FormKit accepts all these as props, and outputs the proper `aria` attributes. Screen readers will now announce the input name, the help text, and that the input is ready for editing:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-accessible-text/example.vue">
</example>

### Setting an initial value

Sometimes you want to add an initial value to an input, such as providing a sensible starting place, or populating pre-saved data from a database. We do this with the `value` prop.

Let's start building an example that we can add to for this guide. Imagining we are building a "character creation form" for a game. Let's assign our character a strength rating. We could use the `range` input with a predefined value of `5` when the users first opens the form:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-vitality-bar/example.vue">
</example>

### Adding validation

Validation is one of the main features of FormKit. It helps the user know if the value they are submitting is correct. Adding [validation](/essentials/validation) is a breeze, with many powerful built-in validation rules already implemented for you. We will be using the `validation` prop to make sure the character is not too strong or too weak. The `validation-visibility` prop allows us to control when to show validation messages to the user — whether immediately, when the user blurs the input, or on form submit. The actual validity state is calculated real-time and always up to date — we simply choose when to expose the messages:

<example
  name="Adding validation to name"
  file="_content/examples/guides/your-first-form/input-validation/example.vue">
</example>

</client-only>

Note that the `min` and `max` props above are built-in browser props for a range input, and represent the top and bottom of the range slider .

### Adding a plugin

Suppose our "backend" requires that data like `strength` be [casted to a number](https://formkit.link/b37c7d36263ab0ee1bd626aa0a405b93). By default, FormKit follows HTML "native" inputs behavior, making all values as "strings". To fix that, we can use one of the coolest features of FormKit — [plugins](/advanced/core#plugins) — which can be thought of as middleware for inputs. With a plugin, which are just functions, we can change how the value of our input is returned:

<example
  name="Adding plugin to cast to number"
  file="_content/examples/guides/your-first-form/input-cast-number/example.vue">
</example>

## Creating the form

First, let's create a basic form and add more inputs so we have content to work with. We will add more features to it in each section, like validation, grouping, and changing values based on other inputs.

We will be using one of the inputs called `form`, this input will make grouping and validation of fields way easier. You just need to wrap all yours inputs inside a `<FormKit type="form">`:

<callout type="info" label="Form values">
The <code>form</code> type will actively collect all the values from child inputs using the <code>name</code> of each input as a data object for you (just like <code>group</code>).
</callout>

<example
  name="Character creation form"
  file="_content/examples/guides/your-first-form/character-basic-form/example.vue">
</example>

### Adding the submit handler

The first feature of a form that we'll explore is that we have a `@submit` event ready to make our life easier when the time comes to submit our form. The `@submit` event gives us as the first argument all the descendant fields the form gathered from the inputs. There is no need to use numerous `v-model`s to collect the form data. Let's add our `createCharacter()` submit handler:

<example
  name="Adding form submit"
  file="_content/examples/guides/your-first-form/character-form-submit/example.vue">
</example>

### Changing the submit button

As convenience when using `type="form"`, the `form` outputs a submit button automatically. For our case, a "Submit" text does not show the intent of the form correctly. To fix that, we can use the `submit-label` prop, which is a `form`-specific feature. We can by simply add `submit-label="Create Character"` to show the intent of the form:

<client-only>

```html
<FormKit
  type="submit"
  @submit="createCharacter"
  submit-label="Create Character"
>
  <!-- Rest of our creation form -->
</FormKit>
```

</client-only>

### Grouping related inputs

While right now the current form works, we can see that some releated inputs are separated, but our backend needs all attributes to be inside an `attributes` property, that is where `group` comes into play, this type is meant to group related inputs together by a common `name`.

Just like the `form` type, you just need to wrap all yours fields inside a `<FormKit type="group" name="attributes">`, don't forget to add the name property:

<example
  name="Grouping inputs"
  file="_content/examples/guides/your-first-form/character-group-attributes/example.vue">
</example>

And that is it! we could stop here for an introduction on how forms and inputs work for FormKit, but we should add more to it, just to make sure we fully understand some core features and some tips that may help your forms go to the next level.

## Updating values based on another input

One thing we should add to make this form even better, is changing the character default `attributes` based on the selected character `class`, for that we will be using some new features:

- [getNode](/advanced/core#getting-a-components-node): `getNode` gets an input using their `id` as an identifier
- [events](/advanced/core#events): `events` listen to changes to a certain input
- [node.input()](/essentials/inputs#using-nodeinput): the `input` function on a node let's us update the value of it

With those features combined we can get an input `node`, add an `events` so we can listen to changes from it, and update a value of another field using the `input` function:

<example
  name="Updating attributes based on the character class"
  file="_content/examples/guides/your-first-form/character-attributes-update/example.vue">
</example>

### Make it into a plugin

The code now got a bit less readable, so let's make it into another file and use a plugin instead, we will also learn another useful feature called [traversal](/advanced/core#traversal) by using the `at` function of a node:

<callout type="warning" label="At uses name">
The <code>at</code> function uses the <code>name</code> attributes instead of the <code>id</code> that <code>getNode</code> uses.
</callout>

<example
  name="Refactor as a plugin"
  :file="[
    '_content/examples/guides/your-first-form/character-plugin/example.vue',
    '_content/examples/guides/your-first-form/character-plugin/plugins.js',
  ]"
  init-file-tab="example.vue">
</example>
