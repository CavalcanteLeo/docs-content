---
title: Your first form
description: Creating your first form and understanding FormKit.
---

# Your first form

<page-toc></page-toc>

## Introduction

Let's start by creating our first FormKit form! We'll learn some of FormKit's key features and how they benefit you. We'll also pick up some nice tips along the way — like how to manage form state without using `v-model`.

<callout type="info" label="Composition API">
This guide assumes you are are familiar with the <a href="https://vuejs.org/guide/introduction.html#api-styles">Vue Composition API</a>.
</callout>

## Our first input

One of the main features of FormKit is its single component API — the `<FormKit />` component. This one component gives you access to _all_ input types. And while some types may extend and add features, they share the same base functionality. You can learn more about inputs [here](/essentials/inputs).

Even without any props, the bare `<FormKit />` component has already given our input a great starting point, with accessible markup, a base `text` input type, and additional features that will be explained in later sections.

### Basic props

#### The type

By default, the `<FormKit />` component will use `type="text"` if no `type` is specified. The `type` is how we specify what input we want. Just like [native inputs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input), we have inputs like `text`, `select`, `checkbox` and so on. However, we are not confined to only "native" inputs, FormKit Pro adds non-native inputs like the `repeater`, `taglist`, and `autocomplete` types, which can handle more complex interactions.

<example
  name="First input"
  file="_content/examples/guides/your-first-form/first-input/example.vue">
</example>

#### The name and id

If you look at the HTML generated by the previous example, you will see that FormKit already created accessible markup. However, as we did not specify the `name` and `id` properties, they were auto-generated for us: `name="text_1" id="input_0"`. Even so, we should always specify the `name` and `id`, as it makes using inputs inside a form easier. These props are used by the `form` and `group` types to collect values from, and pass values down to, their children based on the `name`:

<example
  name="Adding name and id"
  file="_content/examples/guides/your-first-form/input-name-id/example.vue">
</example>

#### Props for accessibility

Our input is still missing some key accessibility functionality like a `label`, `help`, and maybe even a `placeholder`. FormKit accepts all these as props, and outputs the proper `aria` attributes. Screen readers will now announce the input name, the help text, and that the input is ready for editing:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-accessible-text/example.vue">
</example>

### Setting an initial value

Sometimes you want to add an initial value to an input, such as providing a sensible starting place, or populating pre-saved data from a database. If we look at an example case about a vitality bar in a character creation form for a game, we could use the `range` input with a predefined value when the users first opens the form, to make that work we can use the `value` prop to add the first initial value to the input:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-vitality-bar/example.vue">
</example>

### Adding validation

Validation is one of the main features of FormKit, it helps the user to know if the value they submited is correct, FormKit makes adding [validation](/essentials/validation) a breaze, with many powerful built-in `validation` rules already implemented for you, we will be using `validation` to make sure that the user is `required` to add a name, and is `not:Admin`:

<example
  name="Adding validation to name"
  file="_content/examples/guides/your-first-form/input-validation/example.vue">
</example>

We should also add a `required` and `max:10` rule to our vitality input:

<client-only>

```html
<FormKit
  type="range"
  name="vitality"
  id="vitality"
  validation="required|max:10"
  label="Vitality"
  value="5"
  min="1"
  max="10"
  step="1"
  help="How much vitality points to start with"
/>
```

</client-only>

### Number casting

Our "backend" will require that our attributes like `vitality` to be [casted to number](https://formkit.link/b37c7d36263ab0ee1bd626aa0a405b93), but by default FormKit follows HTML "native" inputs behaviour making all values as "strings", so to fix that we can use one of the coolest features that FormKit has, [Plugins](/advanced/core#plugins), with plugins we can change how the value of an inputs is returned to us:

<example
  name="Adding plugin to cast to number"
  file="_content/examples/guides/your-first-form/input-cast-number/example.vue">
</example>

## Creating the form

First, let's create a basic form so we have content to work with. Our example will be a pretend character creation form, we will add more features to it at each section, like validation, grouping, changing values based on other fields, and so on.

We will be using one of the inputs called `form`, this input will make grouping and validation of fields way easier, you just need to wrap all yours fields inside a `<FormKit type="form">`:

<callout type="info" label="Form values">
The <code>form</code> type will actively collect all the values from child inputs using the <code>name</code> of each input as a data object for you (just like <code>group</code>).
</callout>

<example
  name="Character creation form"
  file="_content/examples/guides/your-first-form/character-basic-form/example.vue">
</example>

### Adding the submit handler

The first feature of a form in FormKit that we will see is that we have a `@submit` event ready to make our life easier when it comes to submiting our form, the `@submit` event gives us as the first argument all fields that the form gathered from the inputs, no need to use `v-model` for it:

<example
  name="Adding form submit"
  file="_content/examples/guides/your-first-form/character-form-submit/example.vue">
</example>

### Changing the submit button

As convinience when using `type="form"` the `form` outputs a submit button automatically, but for our case a "Submit" text does not show the intent of the form correctly, so to fix that we can use a nice feature that the `form` has to offer, and that is the `submit-label` prop, we can by simply adding `submit-label="Create Character"` show the intent of the form as a whole:

<client-only>

```html
<FormKit
  type="submit"
  @submit="createCharacter"
  submit-label="Create Character"
>
  <!-- Rest of our creation form -->
</FormKit>
```

</client-only>

### Grouping related inputs

While right now the current form works, we can see that some releated inputs are separated, but our backend needs all attributes to be inside an `attributes` property, that is where `group` comes into play, this type is meant to group related inputs together by a common `name`.

Just like the `form` type, you just need to wrap all yours fields inside a `<FormKit type="group" name="attributes">`, don't forget to add the name property:

<example
  name="Grouping inputs"
  file="_content/examples/guides/your-first-form/character-group-attributes/example.vue">
</example>

And that is it! we could stop here for an introduction on how forms and inputs work for FormKit, but we should add more to it, just to make sure we fully understand some core features and some tips that may help your forms go to the next level.

## Updating values based on another input

One thing we should add to make this form even better, is changing the character default `attributes` based on the selected character `class`, for that we will be using some new features:

- [getNode](/advanced/core#getting-a-components-node): `getNode` gets an input using their `id` as an identifier
- [events](/advanced/core#events): `events` listen to changes to a certain input
- [node.input()](/essentials/inputs#using-nodeinput): the `input` function on a node let's us update the value of it

With those features combined we can get an input `node`, add an `events` so we can listen to changes from it, and update a value of another field using the `input` function:

<example
  name="Updating attributes based on the character class"
  file="_content/examples/guides/your-first-form/character-attributes-update/example.vue">
</example>

### Make it into a plugin

The code now got a bit less readable, so let's make it into another file and use a plugin instead, we will also learn another useful feature called [traversal](/advanced/core#traversal) by using the `at` function of a node:

<callout type="warning" label="At uses name">
The <code>at</code> function uses the <code>name</code> attributes instead of the <code>id</code> that <code>getNode</code> uses.
</callout>

<example
  name="Refactor as a plugin"
  :file="[
    '_content/examples/guides/your-first-form/character-plugin/example.vue',
    '_content/examples/guides/your-first-form/character-plugin/plugins.js',
  ]"
  init-file-tab="example.vue">
</example>

## Adding group validation

Now that our form has most features that we need, there is something that we should add to improve the validation, a group validation to check if the attributes do not exceed 15, otherwise the user should always max out all attributes, and classes wouldn't matter, to make that work we will be learning a new feature, adding [custom rules](/essentials/validation#custom-rules):

<example
  name="Adding custom rule to group"
  :file="[
    '_content/examples/guides/your-first-form/character-group-rule/example.vue',
    '_content/examples/guides/your-first-form/character-group-rule/plugins.js',
    '_content/examples/guides/your-first-form/character-group-rule/rules.js',
  ]"
  init-file-tab="example.vue">
</example>
