---
title: Your first form
description: Creating your first form and understanding FormKit.
---

# Your first form

<page-toc></page-toc>

## Introduction

Let's start by creating our first FormKit form! We'll learn some of FormKit's key features and how they benefit you. We'll also pick up some nice tips along the way — like how to manage form state without using `v-model`.

<callout type="info" label="Composition API">
This guide assumes you are are familiar with the <a href="https://vuejs.org/guide/introduction.html#api-styles">Vue Composition API</a>.
</callout>

## Our first input

One of the main features of FormKit is its single component API — the `<FormKit />` component. This one component gives you access to _all_ input types. And while some types may extend and add features, they share the same base functionality. You can learn more about inputs [here](/essentials/inputs).

Even without any props, the bare `<FormKit />` component has already given our input a great starting point, with accessible markup, a base `text` input type, and additional features that will be explained in later sections.

### Basic props

#### The type

By default, the `<FormKit />` component will use `type="text"` if no `type` is specified. The `type` is how we specify what input we want. Just like [native inputs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input), we have inputs like `text`, `select`, `checkbox` and so on. However, we are not confined to only "native" inputs, FormKit Pro adds non-native controls like the `repeater`, `taglist`, and `autocomplete` types, which can handle more complex interactions.

<example
  name="First input"
  file="_content/examples/guides/your-first-form/first-input/example.vue">
</example>

#### The name and id

If you look at the HTML generated by the previous example, you will see that FormKit already created accessible markup. However, as we did not specify the `name` and `id` properties, they were auto-generated for us: `name="text_1" id="input_0"`. Even so, we should always specify the `name` and `id`, as it makes using inputs inside a form easier. These props are used by the `form` and `group` types to collect values from, and pass values down to, their children based on the `name`:

<example
  name="Adding name and id"
  file="_content/examples/guides/your-first-form/input-name-id/example.vue">
</example>

#### Props for accessibility

Our input is still missing some key accessibility functionality like a `label`, `help`, and maybe even a `placeholder`. FormKit accepts all these as props, and outputs the proper `aria` attributes. Screen readers will now announce the input name, the help text, and that the input is ready for editing:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-accessible-text/example.vue">
</example>

### Setting an initial value

Sometimes you want to add an initial value to an input, such as providing a sensible starting place, or populating pre-saved data from a database. We do this with the `value` prop.

Let's start building an example that we can add to for this guide. Imagining we are building a "character creation form" for a game. Let's assign our character a strength rating. We could use the `range` input with a predefined value of `5` when the users first opens the form:

<example
  name="Adding label and help texts"
  file="_content/examples/guides/your-first-form/input-vitality-bar/example.vue">
</example>

### Adding validation

Validation is one of the main features of FormKit. It helps the user know if the value they are submitting is correct. Adding [validation](/essentials/validation) is a breeze, with many powerful built-in validation rules already implemented for you. We will be using the `validation` prop to make sure the character is not too strong or too weak. The `validation-visibility` prop allows us to control when to show validation messages to the user — whether immediately, when the user blurs the input, or on form submit. The actual validity state is calculated real-time and always up to date — we simply choose when to expose the messages:

<example
  name="Adding validation to name"
  file="_content/examples/guides/your-first-form/input-validation/example.vue">
</example>

</client-only>

Note that the `min` and `max` props above are built-in browser props for a range input, and represent the top and bottom of the range slider .

### Adding a plugin

Suppose our "backend" requires that data like `strength` be [casted to a number](https://formkit.link/b37c7d36263ab0ee1bd626aa0a405b93). By default, FormKit follows HTML "native" inputs behavior, making all values as "strings". To fix that, we can use one of the coolest features of FormKit — [plugins](/advanced/core#plugins) — which can be thought of as middleware for inputs. With a plugin, which are just functions, we can change how the value of our input is returned:

<example
  name="Adding plugin to cast to number"
  file="_content/examples/guides/your-first-form/input-cast-number/example.vue">
</example>

## Creating the form

First, let's create a basic form and add more inputs so we have content to work with. We will add more features to it in each section, like validation, grouping, and changing values based on other inputs.

We will use one of the inputs called `form`, which will make grouping and validation of fields much easier. You just need to wrap all yours inputs inside a `<FormKit type="form">`:

<callout type="info" label="Form values">
The <code>form</code> type will actively collect all the values from child inputs using the <code>name</code> of each input as a data object for you (just like <code>group</code>).
</callout>

<example
  name="Character creation form"
  file="_content/examples/guides/your-first-form/character-basic-form/example.vue">
</example>

### Adding the submit handler

The first feature of a form that we'll explore is that we have a `@submit` event ready to make our life easier when the time comes to submit our form. The `@submit` event gives us as the first argument all the descendant fields the form gathered from the inputs. There is no need to use numerous `v-model`s to collect the form data. Let's add our `createCharacter()` submit handler:

<example
  name="Adding form submit"
  file="_content/examples/guides/your-first-form/character-form-submit/example.vue">
</example>

### Changing the submit button

As convenience when using `type="form"`, the `form` outputs a submit button automatically. For our case, a "Submit" text does not show the intent of the form correctly. To fix that, we can use the `submit-label` prop, which is a `form`-specific feature. We can by simply add `submit-label="Create Character"` to show the intent of the form:

<client-only>

```html
<FormKit
  type="submit"
  @submit="createCharacter"
  submit-label="Create Character"
>
  <!-- Rest of our creation form -->
</FormKit>
```

</client-only>

### Grouping related inputs

While the form works right now, we can see that some related inputs are separated (i.e., the form data is a flat structure where all form data are siblings). Suppose our backend needs all attributes inside an `attributes` property. We can use the `group` type to group related inputs together by a common `name`.

Just like the `form` type, you can wrap all yours fields inside a `<FormKit type="group" name="attributes">`. Don't forget to add the name property:

<example
  name="Grouping inputs"
  file="_content/examples/guides/your-first-form/character-group-attributes/example.vue">
</example>

And that is it! We could stop here for an introduction on how forms and inputs work with FormKit. However, let's keep going to make sure we fully understand some core features and tips that may take your forms to the next level.

## Updating values based on another input

One thing we can do to improve this form is to change the character's default `attributes` based on the selected character `class`. For that, we will be using some new features:

- [getNode](/advanced/core#getting-a-components-node): `getNode` gets an input's core node using their `id` as an identifier. Each input has an associated core node.
- [events](/advanced/core#events): `events` listen to changes to a certain input.
- [node.input()](/essentials/inputs#using-nodeinput): the `input` function on a node lets us update the value of it.

With those features combined, we can get an input's core `node`, listen for and respond to `events`, and update a value of another field using the `input` function:

<example
  name="Updating attributes based on the character class"
  file="_content/examples/guides/your-first-form/character-attributes-update/example.vue">
</example>

### Make it into a plugin

The code now got a bit less readable, so let's extract the logic to another file and use a plugin instead. We will also learn another useful feature called [traversal](/advanced/core#traversal) by using the `at` function of a node:

<callout type="warning" label="at() uses name">
The <code>at</code> function uses the <code>name</code> attributes instead of the <code>id</code> that <code>getNode</code> uses.
</callout>

<example
  name="Refactor as a plugin"
  :file="[
    '_content/examples/guides/your-first-form/character-plugin/example.vue',
    '_content/examples/guides/your-first-form/character-plugin/plugins.js',
  ]"
  init-file-tab="example.vue">
</example>

## Adding group validation

Now that our form has most features that we need, there is something that we should add to improve the validation, a group validation to check if the attributes do not exceed 15, otherwise the user should always max out all attributes, and classes wouldn't matter, to make that work we will be learning a new feature, adding [custom rules](/essentials/validation#custom-rules):

<example
  name="Adding custom rule to group"
  :file="[
    '_content/examples/guides/your-first-form/character-group-rule/example.vue',
    '_content/examples/guides/your-first-form/character-group-rule/plugins.js',
    '_content/examples/guides/your-first-form/character-group-rule/rules.js',
  ]"
  init-file-tab="example.vue">
</example>
